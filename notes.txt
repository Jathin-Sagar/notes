DevOps Notes
<<lsblk
lsblk to display block devices
lsblk -a To display empty block devices.  
lsblk -b print size in bits
lsblk -z print zone model
lsblk -d skip slave entries
lsblk -i to use ascii characters for tree formation
lsblk -m  To print information about device owner, group, and mode of block devices.  
lsblk -o SIZE,NAME,MOUNTPOINT To print selected columns of block-devices. 
lsblk -dn hide column headings
lsblk -help display help section
lsblk
<<tar 
(tape archive)
the command iThe tar command is often used for creating compressed archive files that can be easily transferred or stored. It can compress multiple files into a single archive file, and the resulting archive can be compressed using different compression algorithms like gzip, bzip2, and xz to reduce its size.s used for creating archive and extracting the archive files it was originally used to create backups to tape drives.
tar cvf create,verbose so it gets update, filename(flag) file.tar hello.txt it shown in the red colour, it is a uncompresed tar archive.
tar xvf file.tar extracts files through archives
tar cvzf file.tar.gz hello.txt it makes a tar file kown as file.tar.gz it is the archive of hello.txt file
tar xvzf file.tar.gz it is used to extract the files through file.tar.gz archives file
tar cvfj file.tar.tbz hello.txt making compressed tar files with the -j option
tar -xvf file.tar -c / tar -xvf file.tar  path of directory used to untar( command which enable the users to extract files that are compressed with tar ,tar.gz)
tar -jxvf file.tar.tbz "hello.txt" untar multiple .tar.tbz, .tar.gz, .tar extract more than one file
tar -czf - file.tar./gz/tbz | wc -c it is used to see the size of archive files in kilobytes
tar rvf file.tar hello.txt updating an existing tar file
tar tf file.tar list the whole archive files
tar -tvf file.tar view the archive
tar tvf file.tar hello.txt  view the archived files with their information
tar tvf file.tar | grep "file.txt" help us to only list the mentioned image or text in grep through archived files.
wildcards are referred to as a wildcard character or wild character in Linux. It is a symbol that is used for representing or replacing multiple characters.
Typically, wildcards are either a question mark (?) which illustrates an individual character or an asterisk (*) which illustrates multiple characters.
tar tvf file.tar --wildcards '*.png' finding a .png image
 tar --delete -f file.tar hello.txt to remove files and a tar archive.
tar
<<cronjobs  

A scheduling tool is a software application or program used to automate and manage tasks that need to be performed at specific times or intervals. Scheduling tools are commonly used to streamline and optimize workflows, reduce errors, and save time and effort for users.

There are many types of scheduling tools available, ranging from simple task scheduling tools like the Unix cron utility to more complex project management software and workflow automation platforms.

Scheduling tools typically allow users to set up recurring tasks, assign resources, and set deadlines or timelines for completion. They may also include features for tracking progress, sending notifications or reminders, and generating reports or analytics.

Some common types of scheduling tools include:

Calendar and appointment scheduling tools: These tools allow users to schedule appointments, meetings, and other events. They may include features for sending reminders, tracking attendance, and rescheduling appointments if needed.

Task scheduling tools: These tools allow users to schedule and automate routine tasks, such as data backups, software updates, or system maintenance tasks.

Project management tools: These tools are designed to manage project timelines, deadlines, and milestones. They may include features for scheduling tasks, assigning resources, and tracking progress towards project goals.

Workforce management tools: These tools are used to manage staff schedules, assign tasks, and track employee time and attendance. They may also include features for managing payroll, benefits, and other HR functions.

Overall, scheduling tools are essential for managing complex workflows and ensuring that tasks are completed efficiently and on time. They are used in a wide range of industries and settings, including business, education, healthcare, and government.
Crontab Operators
Cron syntax also utilizes operators for performance. Operators are large inland that operates effectively on the Cron attribute values. The operators are discussed below-

Asterisk operator (*)
The asterisk operator denotes any significance or already. Suppose you see an asterisk (*) in the Hour domain, it implies the job will be done every hour. It represents all values. Utilization of this operator is to gather operating for the entire month or week.

Comma Operator (,)
You can stipulate a range of items for regurgitation using the comma operator. It also defines distinct unique values.

For Instance, if you enter 2,5,8 in the Hour domain, the assignment will execute at 2 a.m., 5 a.m., and 8 a.m.

Hyphen Operator (-)
You can stipulate a set of outcomes using the hyphen operator. If you enter 2-5 in the Weekday domain, the assignment will execute every weekday (From Tuesday to Friday). It also represents a set of parameters.

Forward slash Operator (/)
The slash operator allows you to specify values that will be repeated over a specific interval between them. This operator can also be used to separate a number into various stages.

For example, if you have */4 in the Hour field, it means the action will be performed every four hours.

It is also equivalent as clarifying 0,4,8,12,16,20. You can utilize a range of data rather than an asterisk even before the slash operator.

For example, 1-30/10 indicates the similar as 1,11,21.

<<unzip
through cmd and also in the system (graphical interface)we can unzip the files,we can extracting compressed files from a ZIP archive. ZIP files are a popular format for compressing and packaging files together, making them easier to transfer and store.
The primary reason for using ZIP files is to save storage space and reduce transfer. 
unzip archive.zip this command is used to unzip the files
unzip archive.zip -d myfiles this command is used to unzip file and save in a directory
unzip archive.zip file.txt unzipig the file and saving as text files
unzip

<<sed
The sed command (short for "stream editor") is a powerful utility in Linux and other Unix-based operating systems that can be used to modify text files.

The sed command is designed to read input files (either from standard input or from one or more files) and apply a set of commands to the text. The commands can be used to perform a wide range of text transformations, such as:

Replacing text: You can use the s command to search for a pattern in the text and replace it with a new string. For example, the command sed 's/hello/goodbye/' will replace all occurrences of the word "hello" with "goodbye" in the input text.

Deleting lines: You can use the d command to delete lines that match a particular pattern. For example, the command sed '/pattern/d' will delete all lines that contain the pattern.

Inserting text: You can use the i command to insert new text before a specified line. For example, the command sed '2i\New line' will insert the text "New line" before the second line of the input text.

Appending text: You can use the a command to append new text after a specified line. For example, the command sed '2a\New line' will append the text "New line" after the second line of the input text.

Transforming text: You can use regular expressions and other sed commands to transform text in a wide range of ways.

The sed command can be used in combination with other Linux utilities to perform complex text processing tasks. It is a powerful tool for manipulating text files and automating text processing tasks on the command line
echo class7 | sed 's/class/jtp/'  here class is changed to jtp
echo class7 | sed 's/7/10/'    in this 7 is changed to 10
 cat msg.txt | sed 's/learn/study/'    in the text file we changed lern word to study
echo class7 class9 | sed 's/class/jtp/g' here /' it only edits one file /g' it changes all the files to jtp   
cat msg.txt | sed 's/learn/study/g'   it only edits one text /g' it changes all the texts to study
cat msg.txt | sed '/jtp/d'    deleting line of jtp    
sed -e 's/red/blue/; s/yellow/black/' exm.txt  modifing multiple sed command
sed -f SedCommands exm.txt   we have used commands applied to the earlier example. So, the output is the same as the previous example
sed '3s/Red/Blue/' exm.txt  at which line we need to change we use this red is changed to blue
echo "Another Demo" | sed 'i\First Demo'  it will append the text
sed '3c\This is a modified line.' exm.txt  modifing the lines 
sed 'y/abc/def/' exm.txt  transfering the characters
sed '=' exm.txt  printing the line number
sed -n '/mango/=' exm.txt  it will display the line number with the word mango
sed
<<awk
The awk command is used for text processing in Linux. Although, the sed command is also used for text processing, but it has some limitations, so the awk command becomes a handy option for text processing. It provides powerful control to the data.

The Awk is a powerful scripting language used for text scripting. It searches and replaces the texts and sorts, validates, and indexes the database.
awk '{ print "Welcome to awk command"}' The above command will print the inputted string every time we execute the command. Press CTRL+D key to terminate the program
cat > student.txt  
Sam CS  
Daniel IT  
John IT  
Arya IT  
Mike ECE  
Helena ECE  
awk '/cs/ {print}' student.txt list the students with specific patterns like cs ece first we need to create file with cat
awk '{print}' student.txt to see all the files
awk '{print $1,$5}' student.txt this command will print the column 1 and 5
NR: It is used to show the current count of the lines. The awk command performs action once for each line. These lines are said as records.

NF: It is used to count the number of fields within the current database.

FS: It is used to create a field separator character to divide fields into the input lines.

OFS: It is used to store the output field separator. It separates the output fields.

ORS: It is used to store the output record separator. It separates the output records. It prints the content of the ORS command automatically.
awk '{print NR $2}' student.txt display line number and column of the given number
awk '{print $NF}' student.txt print the last fileld of the file
awk 'BEGIN { ORS ="-"} {print $0}' student.txt seperate the output by _underscore
awk 'BEGIN { for(i=1;i<=8;i++) print "square of", i, "is",i*i; }' print the square of 1 to 8.
Sam,75,100  
Daniel,80,100  
John,74,100  
Arya,85,100  
Mike,70,100   
Helena,74,100 
awk -F"," '{x+=$3}END{print x}' student.txt  to find out the total marks of the students
awk -F, '{a[$1]+=$2;}END{for(i in a)print i", "a[i];}' student.txt print the individual's name with his marks
awk 'BEGIN{x=exp(8); print x}'   print the value of exp 8

awk
<<ls
ls > bharath in this all the files contains in the directory is shown in bharath with cat jathin we can see it
1>&and percentile directory (standared output stdout)/2 &>and percentile directory (standared error stderr) sai now the file is getting created we can see it by using less or more command but , we can use gedit it opens the file in the folder  , 1 > sai for this we get the command not found
ls
1 > filename 2 >& 1 in this both the standard output and standard error is send to the file name
<<uname
The command ‘uname‘ displays the information about the system
uname -a  It prints all the system information in the following order: Kernel name, network node hostname, kernel release date, kernel version, machine hardware name, hardware platform, operating system
uname -s print kernal name
uname -n print hostname
uname -r print kernal release date
uname -v version of the current kernel
uname -m print machine hardware name
uname -p print machine processor
uname -i print the platform of hardware
uname -o print the name of the operating system
uname

<<$
echo is used infront of all the variables
$$ pid of the current shell
$! pid if last background command
$? existing status of the last command executed
$0 filenam eof the current script
$n/1/2 these variable corresponds to the argument with which a script was invoked.her n is a positive decimal number corresponding to the position of an argument ex 1st is 1 2nd s 2
$# number of arguments supplied to a script
$* all the arguments are double quotes,if the script recives 2 arguments then $* is equalent to $1 $2
$@all the arguments are individually double quoted if a script recives two arguments $@ is equivalent to$1 $2
$SHELL is a special shell variable that contains the pathname of the user's preferred shell.
cat /etc/shells  The list of all the shells which are currently installed in our Linux system is stored in the ‘shells’ file which is present in /etc folder of the system. It has read-only access by default and is modified automatically whenever we install a new shell in our system. As we can see, the cat command displays the various installed shells along with their installation paths..
In Unix-like operating systems, echo {A} and echo "{A}" are different in terms of how the shell performs brace expansion and variable expansion.
<< echo {A} and echo "{A}"
echo {A} is an example of brace expansion, which is a feature of many Unix shells that allows you to generate a list of strings by specifying a pattern inside curly braces. In this case, the pattern is a single character "A", so brace expansion generates a list that contains just the string "A". When you run the echo command with this argument, it simply prints the string "A" to the terminal.

echo "{A}" is an example of a string literal that contains the character sequence "{A}". When you run the echo command with this argument, it simply prints the string "{A}" to the terminal, without any further expansion or processing.

In summary, echo {A} generates a list of strings using brace expansion and prints the resulting string to the terminal, while echo "{A}" simply prints a string literal to the terminal without any expansion.
echo {A} and echo "{A}"

<< #!/bin/bash


#!/bin/bash



